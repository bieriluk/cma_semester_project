---
title: "Project code"
author: "Lukas Bieri (bieriluk) & Valentin Hett (hettval1)"
date: "23.06.2023"
format: html
editor: source
---


# Improved Transport Mode Detection & Public Transport Punctuality Assessment

## 1. Information

### 1.1 Project Info


**Module:** Patterns and Trends HS22

**Course:** Semester Project

**Lecturer:** Prof. Dr. Patrick Laube

**Assistent Lecturers:** Nils Ratnaweera & Dominic Lüönd

**Autors:** Valentin Hett (hettval1) & Lukas Bieri (bieriluk)

**Date:** 23.06.2023


### 1.2 Software used

**R version 4.2.1 (2022-06-23 ucrt)** -- "Funny-Looking Kid" Copyright (C) 2022 The R Foundation for Statistical Computing Platform: x86_64-w64-mingw32/x64 (64-bit)

**RStudio 2023.06.0+421** "Mountain Hydrangea" Release (583b465ecc45e60ee9de085148cd2f9741cc5214, 2023-06-05) for windows
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) RStudio/2023.06.0+421 Chrome/110.0.5481.208 Electron/23.3.0 Safari/537.36


## 2. Preparation

```{r}
#| output: false
#| warning: false
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, repos = "http://cran.us.r-project.org", 
                     dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

packages <- c("ggplot2", "dplyr", "tidyr", "readr", "zoo", "data.table", "sf", "terra", "tmap", "stats", "randomForest", "lubridate", "trajr", "gstat", "geosphere", "nngeo", "vegan", "hms", "tibble", "useful", "DescTools")

ipak(packages)
```


```{r}
tmap_mode(mode = "view")
```

## 3. Daten(vor)verarbeitung

### 3.1 Import, check and transport data

#### 3.1.1 Boundries

```{r}
st_layers("datasets/swissTLMRegio_BOUNDARIES_LV95.gdb")
kanton_zh <- st_read("datasets/swissTLMRegio_BOUNDARIES_LV95.gdb", layer = "TLMRegio_KANTONSGEBIET")
kanton_zh <- kanton_zh |>
  filter(NAME == "Zürich")

st_crs(kanton_zh)

tm_shape(kanton_zh) +
  tm_polygons() +
  tm_basemap("Esri.WorldImagery")

```


#### 3.1.2 Posmo data
```{r}
posmo <- read_delim("datasets/posmo_2023-01-01T00-00-00_2023-06-16T23-59-59_unvalidated_def.csv", delim = ",")

posmo_valid <- read_delim("datasets/posmo_2023-01-01T00-00-00_2023-06-16T23-59-59_validated_def.csv", delim = ",")

```

Check if the import got the Time Zone for the POSIXct colum correct (compare with the first entry in the imported data with the raw data):
```{r}
str(posmo)
Sys.time()
```

Store your data frame as a spatial data frame and transform the coordinate system from WGS84 (i.e. EPSG 4326) to CH1903+ LV95 (EPSG 2056)
```{r}
posmo <- st_as_sf(posmo, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056) |>
  st_filter(kanton_zh, .pred = st_intersects)

posmo_valid <- st_as_sf(posmo_valid, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056) |>
  st_filter(kanton_zh, .pred = st_intersects)

head(posmo)
tm_shape(posmo) +
  tm_dots(col = "red") +
  tm_basemap("Esri.WorldImagery")
```

Extract the coordinates into separate colums to use them for euclidean distance calculation:
```{r}
posmo_coordinates <- st_coordinates(posmo)

posmo <- cbind(posmo, posmo_coordinates)
```


#### 3.1.3 Railway routes data
incl. Normalspurbahn, Schmalspurbahn, Standseilbahn, Seilbahn, Gondelbahn, Sessellift, Autoverlad
excl. Güterbahn, Museumsbahn, Bahn ausser Betrieb, Bahn im Bau
```{r}
st_layers("datasets/swissTLMRegio_Produkt_LV95.gdb")
train_routes <- st_read("datasets/swissTLMRegio_Produkt_LV95.gdb", layer = "TLMRegio_Railway")
st_crs(train_routes)

train_routes <- train_routes |>
  filter(OBJVAL != 3 & UNDERCONST == 0) |>
  st_filter(kanton_zh, .pred = st_intersects)

train_stops <- st_read("datasets/swissTLMRegio_Produkt_LV95.gdb", layer = "TLMRegio_Terminal")

train_stops <- train_stops |>
  filter(OBJVAL == 1) |>
  st_filter(kanton_zh, .pred = st_intersects)

tm_shape(train_routes) +
  tm_lines(col = "red") +
  tm_shape(train_stops) + 
  tm_dots(col = "red") +
  tm_basemap("Esri.WorldImagery")
  
```


#### 3.1.4 Bus & tram data
```{r}
st_layers("datasets/Linien_des_offentlichen_Verkehrs_-OGD.gpkg")
bus_routes <- st_read("datasets/Linien_des_offentlichen_Verkehrs_-OGD.gpkg", layer = "ZVV_LINIEN_L")
st_crs(bus_routes)
bus_routes

tm_shape(bus_routes)+
  tm_lines()+
  tm_basemap("Esri.WorldImagery")

```

#### 3.1.5 Road network data
```{r}
st_layers("datasets/swissTLMRegio_Produkt_LV95.gdb")
roads <- st_read("datasets/swissTLMRegio_Produkt_LV95.gdb", layer = "TLMRegio_Road")
roads <- roads |>
  st_filter(kanton_zh, .pred = st_intersects)

tm_shape(roads) +
  tm_lines(col = "red") +
  tm_basemap("Esri.WorldImagery")

```


### 3.2  Getting an overview & EDA

#### 3.2.1 For how long were the individual tracked? Are there gaps? Were all individuals tracked concurrently or sequentially?
```{r}

head(posmo)
tail(posmo)
```


#### 3.2.2 How many individuals were tracked 
```{r}
posmo$user_id |> unique()
```
--> 1 Individuals, because for the moment we are only working with on data set (not the POSMO Pool)

### 3.3  Filtering & Outlier detection

#### 3.3.1 Filter the data for testing & checkin the method
Choose a single day for this step (13.04.2023, because many different visited places that day) and filter your data:
```{r}
posmo_filter <- posmo  #|>
#    filter(as.Date(datetime) == "2023-04-13")

posmo_valid_filter <- posmo_valid  |>
    filter(as.Date(datetime) == "2023-04-13")

test <- filter(posmo, hour(datetime) >= 7 & hour(datetime) <= 17)

hour(as_hms("17:00:00"))
```

```{r}
ggplot(posmo_filter, aes(X,Y, color = datetime)) +
  geom_point() +
  geom_path() +
  coord_equal()


tm_shape(posmo_filter) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")
```
X = E, Y = N


#### 3.3.2 Remove deuplicate time stamps
Calculate timelag and also remove values with the same time stamp by summarising unsing the mean.
```{r}

posmo_filter_clean <- posmo_filter|>
  st_drop_geometry()|>
  select(datetime, X, Y)|>
  mutate(
    datetime = unclass(datetime)
    ) |>
  group_by(datetime)|>
  summarise(
    X = mean(X, na.rm = TRUE),
    Y = mean(Y, na.rm = TRUE)
  ) |>
  ungroup()|>
  mutate(
    datetime = as.POSIXct(datetime, origin = '1970-01-01', tz = "UTC")
    )|>
  st_as_sf(coords = c("X","Y"), crs = 2056, remove = FALSE) 

n_distinct(posmo_filter_clean$datetime)
n_distinct(posmo_filter$datetime)
```


#### 3.3.3 Temporal sampling interval cleaning
Calculate timelag to figure out a appropriate temporal window:
```{r}
posmo_filter_clean <- posmo_filter_clean |>
  mutate(timelag_s = as.numeric(difftime(lead(datetime), datetime)))

```

Look for negative timelag values and visually validate that they are corrective algorith errors, then eliminate these rows incl. NA's. 
```{r}
posmo_filter_clean |>
    filter(timelag_s < 0)

posmo_filter_clean |>
    filter(is.na(timelag_s))

tm_shape(slice(posmo_filter_clean,1261)) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")
  
posmo_filter_clean <- posmo_filter_clean |>
    filter(timelag_s > 0)

```


So what does the timelag between measurement points look like:
```{r}
tail(posmo_filter_clean)
mean(posmo_filter_clean$timelag_s, na.rm = TRUE)
median(posmo_filter_clean$timelag_s, na.rm = TRUE)
min(posmo_filter_clean$timelag_s, na.rm = TRUE)
max(posmo_filter_clean$timelag_s, na.rm = TRUE)


posmo_filter_clean|> 
  ggplot(aes(timelag_s)) +
  geom_histogram(binwidth = 1) +
  lims(x = c(0, 20000)) +
  scale_y_log10() +
  scale_x_log10()

posmo_filter_clean |> 
  ggplot(aes(datetime, timelag_s)) +
  geom_point() + 
  geom_line()

```

#### 3.3.4 Outlier detection and removal
Calculate further features for outlier detection
```{r}
posmo_filter_clean <- posmo_filter_clean |> 
  mutate(steplength_m = sqrt((X-lead(X,1))^2 + (Y-lead(Y,1))^2)) |> 
  mutate(speed_ms = steplength_m/timelag_s)
posmo_filter_clean
```
X = E, Y = N

Identify and remove outliers
```{r}
mean(posmo_filter_clean$speed_ms, na.rm = TRUE)
median(posmo_filter_clean$speed_ms, na.rm = TRUE)
min(posmo_filter_clean$speed_ms, na.rm = TRUE)
max(posmo_filter_clean$speed_ms, na.rm = TRUE)

posmo_filter_clean |>
    filter(speed_ms > 140)

tm_shape(slice(posmo_filter_clean,1258:1260)) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")
```


### 3.4  Resampling

Adding new rows with the resampled time stamps and linearly interpolating them using na.approx() 
```{r}
# Create a new df with all necessary time stamps

resamp_timestamps <- seq.POSIXt(from = ceiling_date(min(posmo_filter_clean$datetime), "10 sec"),
                                to = floor_date(max(posmo_filter_clean$datetime), "10 sec"), 
                                by = 10)
resamp_timestamps <- as.data.frame(resamp_timestamps)

resamp_timestamps <- resamp_timestamps |> 
  as.data.frame() |> 
  rename(datetime = resamp_timestamps)

# Combine the df with the resulting df adding rows with NA for the nessecary time stamps
posmo_filter_resamp <- posmo_filter_clean |>
  select(datetime, X, Y, geometry) |>
  full_join(resamp_timestamps, by = "datetime") |>
  arrange(datetime)

n_distinct(posmo_filter_resamp$datetime)
sum(n_distinct(posmo_filter_clean$datetime), n_distinct(resamp_timestamps$datetime))

# Linearly interpolate the missing values (coordinates) & Filter to only the resampled rows
posmo_filter_approx <- posmo_filter_resamp |>
  st_drop_geometry()|>
  mutate(X = na.approx(X),
         Y = na.approx(Y)
         ) |>
  filter(second(datetime) %in%  c(0, 10, 20, 30, 40, 50)) |>
  st_as_sf(coords = c("X","Y"), crs = 2056, remove = FALSE)

posmo_filter_approx

tm_shape(posmo_filter_approx) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")

```
**Change resampling to 15s!**


## 4. Segmentation

### 4.1 Get an overview
```{r}
ggplot(posmo_filter_approx, aes(X,Y, color = datetime)) +
  geom_point() +
  geom_path() +
  coord_equal()
```
X = E, Y = N

```{r}
posmo_filter_approx|> 
  head(50) |> 
  ggplot(aes(datetime, 1)) +
  geom_point()
```

### 4.2 (a) Specify a temporal windows v for in which to measure Euclidean distances
Calculate timelag to figure out a appropriate temporal window:
```{r}
posmo_filter_approx <- posmo_filter_approx|>
  mutate(timelag_s = as.numeric(difftime(lead(datetime), datetime)))
```

So what does the timelag between measurement points look like:
```{r}
tail(posmo_filter_approx)
mean(posmo_filter_approx$timelag_s, na.rm = TRUE)
median(posmo_filter_approx$timelag_s, na.rm = TRUE)
min(posmo_filter_approx$timelag_s, na.rm = TRUE)
max(posmo_filter_approx$timelag_s, na.rm = TRUE)

```

For this exercise we try to use the data as is and try it with a window of 6 steps and 6 steps forward and backward in the data. This is v = 2min, because the timelag is 10s.

### 4.3 (b) Measure the distance from every point to every other point within this temporal window v
```{r}
posmo_filter_approx <- posmo_filter_approx |> 
  mutate(
    n_plus10 = sqrt((lead(X,10) - X)^2 + (lead(Y,10) - Y)^2),
    n_plus20 = sqrt((lead(X,20) - X)^2 + (lead(Y,20) - Y)^2),
    n_minus10 = sqrt((lag(X,10) - X)^2 + (lag(Y,10) - Y)^2),
    n_minus20 = sqrt((lag(X,20) - X)^2 + (lag(Y,20) - Y)^2),
    steplength_m = sqrt((X-lead(X,1))^2 + (Y-lead(Y,1))^2),
    speed_ms = steplength_m/timelag_s
  )
```
Segmentation: temporal window v = 200s, Filtering: 60s


```{r}
posmo_filter_approx <- posmo_filter_approx |> 
  rowwise() |> 
  mutate(
    stepMean = mean(c(n_minus10, n_minus20, n_plus10, n_plus20))
  ) |> 
  ungroup()
```
Careful, you need rowwise() for the mutate() function to caclulate mean() for every row. You need to ungroup it in the end, because your data frame has the rowwise grouping saved.

### 4.4 (c) Remove “static points”

We need to determine the appropriate threshold where the points are stationary. It helps to visualize the data:
```{r}
ggplot(posmo_filter_approx, aes(stepMean)) +
  geom_histogram(binwidth = 10) +
  geom_vline(xintercept = median(posmo_filter$stepMean, na.rm = TRUE))
```

These are points where the average distance is less than a given threshold or the min speed

To find a good threshold, I tried different distances which I would realistically travel when not being stationary. ave.distance d =100m
A trip (Segment) may be conducted with different transportation modes, and can, therefore, be divided into segments where each segment indicate a certain transport mode. For instance, a trip can start with a car and end with a bus. First, we identify GPS tracking stops that are longer than a specific threshold (30s). A stop is considered when consecutive points in an interval of above 30 s do not have a speed higher than 2 km/h. The stops are where the transportation mode might have changed and subsegments might be formed.
```{r}
posmo_filter_segm <- posmo_filter_approx |>
    ungroup() |>
    mutate(
      static = (stepMean < 100) | (lead(speed_ms,1) < 0.555555 & lead(speed_ms,2) < 0.555555 & lag(speed_ms,1) < 0.555555 & lag(speed_ms,2) < 0.555555)) |>
    drop_na(static)
```

### 4.5 Visualize stops
```{r}
ggplot(posmo_filter_segm, aes(X,Y)) +
  geom_path() +
  geom_point(aes(color = static)) +
  coord_equal()

tm_shape(posmo_filter_segm) +
  tm_dots(col = "static") +
  tm_basemap("Esri.WorldImagery")

```
Moving 10 in approx. 300sec being the threshold and no more than 2km/h within 30s for being stationary seems to line up well with the reality when visualizing it.

### 4.6 Segment-based analysis (segmentation at stationary points)
Create function for segmentation at the stationary points:
```{r}
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}
```

Run the function on the data:
```{r}
posmo_filter_segm <- posmo_filter_segm |>
    mutate(segment_id = rle_id(static))

head(posmo_filter_segm)
```

### 4.7 Visualize segmented trajectories
```{r}
ggplot(posmo_filter_segm, aes(X,Y)) +
  geom_path() +
  geom_point(aes(color = segment_id)) +
  coord_equal()

tm_shape(posmo_filter_segm) +
  tm_dots(col = "segment_id") +
  tm_basemap("Esri.WorldImagery")
```

Seems to line up well with ground truth for that day and the trips I took. If I would want to improve the segmentation, I would have to compare the details with reality and maybe smoothen out the differences in timelags.

Remove segments with a duration of less than 60s and static points
```{r}
posmo_filter_short_segm <- posmo_filter_segm |> 
  group_by(segment_id)|>
  summarise(
    seg_length = sum(timelag_s, na.rm = TRUE)
  ) |>
  ungroup()|>
  mutate(
    short = seg_length < 60
  ) |>
  select(segment_id, short) |>
  st_drop_geometry()

posmo_filter_segm_clean <- posmo_filter_segm |> 
  left_join(posmo_filter_short_segm, by = "segment_id") |> 
  filter(static == FALSE) |>
  filter(short == FALSE) |>
  select(datetime, X, Y, geometry, segment_id)

tm_shape(posmo_filter_segm_clean) +
  tm_dots(col = "segment_id") +
  tm_basemap("Esri.WorldImagery")

unique(posmo_filter_segm_clean$segment_id)
```
**Offene Frage: Warum werden im Code der Exercise die "static points" nicht entfernt? So richtig wie ich das hier gemacht habe?**


## 5. Feature extraction

### 5.1 Feature extraction on the raw point data
```{r}
posmo_filter_segm_clean <- posmo_filter_segm_clean |> 
  mutate(timelag_s = as.numeric(difftime(lead(datetime), datetime)),
         steplength_m = sqrt((X-lead(X,1))^2 + (Y-lead(Y,1))^2),
         speed_ms = steplength_m/timelag_s,
         acc_mss = as.numeric(speed_ms - (lead(speed_ms)) / timelag_s),
         long = st_coordinates(st_transform(posmo_filter_segm_clean, 4326))[,1], 
         lat = st_coordinates(st_transform(posmo_filter_segm_clean, 4326))[,2],
         azi = c(st_azimuth(head(st_geometry(posmo_filter_segm_clean),-1),
                            head(lead(st_geometry(posmo_filter_segm_clean),1),-1)),NA)
         ) |> 
  rowid_to_column(var = "id") |>
  drop_na() 
  
#To add in future if appropriate:
#,
#        bearing_from = atan2((cos(lat)*sin(lead(lat)) - sin(lat)*cos(lead(lat))* cos(long - lead(long))), (cos(lead(lat))* sin(long - lead(long)))),
#         bearing_geosp = bearing(st_coordinates(st_transform(posmo_filter_segm_clean, 4326)), lead(st_coordinates(st_transform(posmo_filter_segm_clean, 4326)),1)),

```
**Wird Bearing hier korrekt berechnet? Was ist der Unterschied zwischen Azimut, Bearing, Direction, turning angles und heading? Was wäre hier am angebrachtesten**

### 5.2 Feature extraction & summary by segment
Therefore, features such as average speed, average acceleration, maximum and minimum speed, acceleration during each segment, segment distance, direction, and duration, are calculated for each segment. 
```{r}
 
posmo_filter_segm_sry <- posmo_filter_segm_clean |> 
  group_by(segment_id)|>
  summarise(
    avgspeed_ms = mean(speed_ms, na.rm = TRUE),
    avgacc_mss = mean(acc_mss, na.rm = TRUE),
    maxspeed_ms = max(speed_ms, na.rm = TRUE),
    minspeed_ms = min(speed_ms, na.rm = TRUE),
    maxacc_mss = max(acc_mss, na.rm = TRUE),
    minacc_mss = min(acc_mss, na.rm = TRUE),
    seg_dist_m = sum(steplength_m, na.rm = TRUE),
    seg_time_s = sum(timelag_s, na.rm = TRUE)
  )

#posmo_filter_segm_startend <- posmo_filter_segm_clean |> 
#  group_by(segment_id)|>
#seg_dir = c(st_azimuth(head(st_geometry(posmo_filter_segm_clean),-1),
#                            head(lead(st_geometry(posmo_filter_segm_clean),1),-1)),NA) #starting point azi to end point
```
**Direction anpassen aus azi zwischen Startpunkt und Endpunkt pro Segment**


And calculate sinuosity (for random walk) using a for loop:
```{r}
iter <- unique(posmo_filter_segm_clean$segment_id)
iter_i <- seq_along(iter)
sin <- numeric(length = length(iter))

for (seg_i in iter_i){
  print(seg_i)
    seg <- iter[seg_i]
    
    mysin <- posmo_filter_segm_clean |> 
    filter(segment_id == seg) |> 
    select(X, Y) |> 
    TrajFromCoords() |> 
    TrajSinuosity()
  
  sin[seg_i] <- mysin
  print(mysin)
}

posmo_filter_segm_sry$sinuosity <- sin


# nächstes mal besser mit purrr
# apply, lappy, sapply, etc. auch möglich aber "schlecht" geschrieben

```
**Siuosity anpassen auf directed walk with a starting and an end point**



## 6. Preliminary multi criteria analysis to eliminate walking segments

However, walking can easily be identified in the GPS-tracking data based on three conditions:
1. segment must have at least two positional recordings, and the segment’s duration should be more than 60 s Gong et al. (2012a). 
2. The second condition is that the segment’s average speed should not be greater than 6 km/h 
(Stopher et al., 2008). 
3. The third condition is that each subsequent point’s maximum speed should not be greater than 12 km/h (Gong et al., 2012b; Stopher et al., 2008). All selected walk segments are checked 
manually in GIS multi-criteria process because, it is difficult to differentiate between various modes in traffic and the traffic pattern for these modes were rather similar (walk, car, bus). After identification of the walk transport mode, those segments are removed from the dataset. 
```{r}

posmo_filter_segm_clean <- left_join(posmo_filter_segm_clean, st_drop_geometry(posmo_filter_segm_sry), by = "segment_id")

posmo_filter_segm_walks <- posmo_filter_segm_clean |> 
  mutate(
    walks = seg_time_s > 60 & avgspeed_ms <= 1.66666 & maxspeed_ms < 3.33333
  )

posmo_filter_segm_onlywalks <- posmo_filter_segm_walks |> 
  filter(walks == TRUE)

tm_shape(posmo_filter_segm_onlywalks) +
  tm_dots(col = "walks") +
  tm_basemap("Esri.WorldImagery")

posmo_filter_segm_onlywalks_sry <- posmo_filter_segm_walks |> 
  st_drop_geometry()|>
  group_by(segment_id)|>
  summarise(
    walk_true = sum(walks == TRUE),
    walk_false = sum(walks == FALSE)
  )|>
  mutate(
    walk_seg = (walk_true / walk_false) > 0.9
    ) |> 
  select(segment_id, walk_seg)


posmo_filter_segm_walks <- left_join(posmo_filter_segm_walks, posmo_filter_segm_onlywalks_sry, by = "segment_id")
posmo_filter_segm_nowalks <- filter(posmo_filter_segm_walks, walk_seg == FALSE)
posmo_filter_segm_onlywalks <- filter(posmo_filter_segm_walks, walk_seg == TRUE)

```


## 7. Unsupervised algorithm using k-means clustering

**For improving k-means clustering add moving window features for speed, steplength and accelaration!**
**And improve outlies removal for the cluster with 130km/h average speed**


```{r}
posmo_filter_seg_kmeans4 <- posmo_filter_segm_nowalks |> 
  st_drop_geometry() |> 
  select(steplength_m, speed_ms, acc_mss, sinuosity, avgspeed_ms) |> 
  data.matrix() |> 
  kmeans(4)

posmo_filter_seg_kmeans4
```

Manually assign TM to the clusters
```{r}
posmo_filter_seg_kmeans4

#posmo_filter_seg_cluster |>
#  filter(as.Date(datetime) == "2023-04-13") |>
#  filter(kmeans4 == 3) |>
#  tm_shape() +
#  tm_dots(col = "kmeans4") +
#  tm_basemap("Esri.WorldImagery")

```

Add cluster number to data frame (later with manually assigned label)
```{r}
posmo_filter_seg_cluster <- posmo_filter_segm_nowalks |> 
  mutate(
    kmeans4 = posmo_filter_seg_kmeans4$cluster
  )

posmo_filter_seg_cluster |>
  filter(as.Date(datetime) == "2023-06-15") |>
  tm_shape() +
  tm_dots(col = "kmeans4") +
  tm_basemap("Esri.WorldImagery")

```
Good dates for Verification are 2023-05-13 (long bike track) and 2023-04-13 (ÖV and car)


Test for non-multi-clusterd segments:
```{r}
test <- posmo_filter_seg_cluster |> 
  group_by(segment_id)|>
  summarise(
    avgspeed_ms = mean(speed_ms, na.rm = TRUE),
    avgacc_mss = mean(acc_mss, na.rm = TRUE),
    maxspeed_ms = max(speed_ms, na.rm = TRUE),
    minspeed_ms = min(speed_ms, na.rm = TRUE),
    maxacc_mss = max(acc_mss, na.rm = TRUE),
    minacc_mss = min(acc_mss, na.rm = TRUE),
    seg_dist_m = sum(steplength_m, na.rm = TRUE),
    seg_time_s = sum(timelag_s, na.rm = TRUE),
    seg_clear = all(min(kmeans4) == max(kmeans4), na.rm = TRUE)
  )

test |>
  filter(seg_clear == TRUE) |>
  tm_shape() +
  tm_dots(col = "segment_id") +
  tm_basemap("Esri.WorldImagery")
```





## 8. GIS multi-criteria process 

### 8.1 Preparation
```{r}

```


### 8.2 Bike mode detection
For the bike mode, three rules are applied:
1. First, the average speed of a trip segment is assumed below 25 km/h. 
2. Second, the maximum speed of the segment should not be greater than 40 km/h. 
3. Third, the total distance in a segment should be below 20 km. 

```{r}

posmo_filter_segm_bike <- posmo_filter_segm_nowalks |> 
  mutate(
    bike = avgspeed_ms < 6.944 & maxspeed_ms <= 11.111 & seg_dist_m < 20000
  )

posmo_filter_segm_onlybike <- posmo_filter_segm_bike |> 
  filter(bike == TRUE)

posmo_filter_segm_nobike <- posmo_filter_segm_bike |> 
  filter(bike == FALSE)

  tm_shape(posmo_filter_segm_onlybike) +
  tm_dots(col = "bike") +
  tm_basemap("Esri.WorldImagery")

```


### 8.3 Train mode detection
For the train mode, three rules are applied:
1. The railway network, and the train stations are collected and used for detecting train mode.
2. Second, the distance from each point of the trip segment to the nearest railway or commuter rail link should be less than 10 m. 
3. Third, the maximum distance of the first and endpoint to the nearest train station should be 75 m (Gong et al., 2012b).

First, based on multimodal transportation network, each sequential pair of GPS points within a train segment is matched to the similar link of the train network.
```{r}
trains_buffer <- train_routes |> 
  st_buffer(10) |> 
  st_union()

tm_shape(trains_buffer) +
  tm_polygons() +
  tm_basemap("Esri.WorldImagery")


posmo_filter_segm_train <- posmo_filter_segm_bike |> 
  mutate(
    train = st_within(posmo_filter_segm_bike, trains_buffer, sparse = FALSE)
  )

posmo_filter_segm_onlytrains <- posmo_filter_segm_train |> 
  filter(train == TRUE)

posmo_filter_segm_notrains <- posmo_filter_segm_train |> 
  filter(train == FALSE)

  tm_shape(posmo_filter_segm_onlytrains) +
  tm_dots(col = "train") +
  tm_basemap("Esri.WorldImagery")
```



### 8.4 Bus mode detection
Three rules, therefore, are applied to identify the bus mode:
1. First, each segment’s positional recording needs to be close to bus routes with unique features, such as bus stops and lanes. 
2. Second, the average speed of 88 km/h is considered (Gong et al., 2012b), while the maximum speed of a segment should be 100 km/h based on the traffic rules. 
3. Third, the maximum distance to the bus station should be less than 75 m. 

The remaining trip segments are considered potential car mode after applying the bus mode rules.

```{r}
bus_buffer <- bus_routes |> 
  st_buffer(15) |> 
  st_union()

tm_shape(bus_buffer) +
  tm_polygons() +
  tm_basemap("Esri.WorldImagery")


posmo_filter_segm_bus <- posmo_filter_segm_train |> 
  mutate(
    bus = st_within(posmo_filter_segm_train, bus_buffer, sparse = FALSE) & avgspeed_ms < 24.4444 & maxspeed_ms <= 27.7778
  )

posmo_filter_segm_onlybus <- posmo_filter_segm_bus |> 
  filter(bus == TRUE)

posmo_filter_segm_nobus <- posmo_filter_segm_bus |> 
  filter(bus == FALSE)

tm_shape(posmo_filter_segm_onlybus) +
  tm_dots(col = "bus") +
  tm_basemap("Esri.WorldImagery")
```

### 8.5 Car mode detection
The rule applied in further identifying the car mode is that each car segment needed to follow the transportation network, and the maximum speed should not be greater than 180 km/h (Biljecki et al., 2013a). 

```{r}
road_buffer <- roads |> 
  st_buffer(25) |> 
  st_union()

tm_shape(road_buffer) +
  tm_polygons() +
  tm_basemap("Esri.WorldImagery")


posmo_filter_segm_car <- posmo_filter_segm_bus |> 
  mutate(
    car = st_within(posmo_filter_segm_bus, road_buffer, sparse = FALSE) & avgspeed_ms > 4.16667 & maxspeed_ms <= 36.1111
  )

posmo_filter_segm_onlycar <- posmo_filter_segm_car |> 
  filter(car == TRUE)

posmo_filter_segm_nocar <- posmo_filter_segm_car |> 
  filter(car == FALSE)

tm_shape(posmo_filter_segm_onlycar) +
  tm_dots(col = "car") +
  tm_basemap("Esri.WorldImagery")
```


### 8.5 Implement on segment level

```{r}
posmo_filter_segm_mca_sry <- posmo_filter_segm_car |> 
  st_drop_geometry()|>
  group_by(segment_id)|>
  summarise(
    bike_true = sum(bike == TRUE),
    bike_false = sum(bike == FALSE),
    train_true = sum(train == TRUE),
    train_false = sum(train == FALSE),
    bus_true = sum(bus == TRUE),
    bus_false = sum(bus == FALSE),
    car_true = sum(car == TRUE),
    car_false = sum(car == FALSE)
  )|>
  mutate(
    bike_seg = (bike_true / bike_false) > 0.9,
    train_seg = (train_true / train_false) > 0.9,
    bus_seg = (bus_true / bus_false) > 0.9,
    car_seg = (car_true / car_false) > 0.5
    ) |> 
  select(segment_id, bike_seg, train_seg, bus_seg, car_seg)


posmo_filter_segm_mca <- left_join(posmo_filter_segm_car, posmo_filter_segm_mca_sry, by = "segment_id")

posmo_filter_segm_mca

posmo_filter_segm_mca <- posmo_filter_segm_mca |>
  mutate(
    tm = ifelse(bike_seg == TRUE & train_seg == FALSE & bus_seg == FALSE,
                "Bike",
                ifelse(bike_seg == FALSE & train_seg == TRUE & bus_seg == FALSE,
                       "Train", 
                       ifelse(bike_seg == FALSE & train_seg == FALSE & bus_seg == TRUE,
                              "Bus",
                              ifelse(bike_seg == FALSE & train_seg == FALSE & bus_seg == FALSE & car_seg == TRUE,
                                     "Car", NA))))
  )


posmo_filter_segm_mca |>
  filter(as.Date(datetime) == "2023-06-15") |>
  tm_shape() +
  tm_dots(col = "tm") +
  tm_basemap("Esri.WorldImagery")

```
Good dates for Verification are 2023-05-13 (long bike track) and 2023-04-13 (ÖV and car)


## 9. Analysis

To few training data an modelling experience to properly implement random Forest algorithm
```{r}
#randomForest(~., data=posmo_filter_segm_multiclass, proximity=TRUE)
```

visualizations:
```{r}
posmo_filter_segm_mca |>
  filter(as.Date(datetime) == "2023-06-15") |>
  tm_shape() +
  tm_dots(col = "tm") +
  tm_basemap("Esri.WorldImagery")
```

Comparison of POSMO, our TM-algorithm and ground truth data:
```{r}
posmo_valid
posmo
posmo_filter_segm_mca

?names
?which.max
?table

mode
```

Resampling of posmo data

Adding new rows with the resampled time stamps and linearly interpolating them using na.approx() 
```{r}
# Create a new df with all necessary time stamps

resamp_timestamps <- seq.POSIXt(from = ceiling_date(min(posmo_filter_clean$datetime), "10 sec"),
                                to = floor_date(max(posmo_filter_clean$datetime), "10 sec"), 
                                by = 10)
resamp_timestamps <- as.data.frame(resamp_timestamps)

resamp_timestamps <- resamp_timestamps |> 
  as.data.frame() |> 
  rename(datetime = resamp_timestamps)

# Combine the df with the resulting df adding rows with NA for the nessecary time stamps
posmo_filter_resamp <- posmo_filter_clean |>
  select(datetime, X, Y, geometry) |>
  full_join(resamp_timestamps, by = "datetime") |>
  arrange(datetime)

n_distinct(posmo_filter_resamp$datetime)
sum(n_distinct(posmo_filter_clean$datetime), n_distinct(resamp_timestamps$datetime))

# Linearly interpolate the missing values (coordinates) & Filter to only the resampled rows
posmo_filter_approx <- posmo_filter_resamp |>
  st_drop_geometry()|>
  mutate(X = na.approx(X),
         Y = na.approx(Y)
         ) |>
  filter(second(datetime) %in%  c(0, 10, 20, 30, 40, 50)) |>
  st_as_sf(coords = c("X","Y"), crs = 2056, remove = FALSE)

posmo_filter_approx

tm_shape(posmo_filter_approx) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")

```



**Ideas for writing:**


Reserch question:
- Change our research questions (they said we could) to the second one being: Where do we see space for improvement with POSMOS TMD which with more time would be woth tying to implement? Support the findings with studies where possible!
- Due to these constaints, this project does not intend to revolutionise TMD in GPS-data, but by experimenting with different apporaches from literature and brainstoming find possible paths to improve TMD of POSMO data, even if not all of them can be algorithmically implemented.



Discussion:
- further improvement possible with elevation modeled for bike mode detection
- using spatial and temporal similarity measures instead of fixed criteria for comparing bus routes and bus departure times (create artificial bus etc. trajectories to compare to GPS trajectories). This however will be computationally demanding when using more complex similarity measures such as LDDS
- Tweeking the inputs for kmeans, particularly the moving window size
- Using accelerometer data from the phone to aide walking, running and bike mode detection
- Improve outlier detection also on a trajectory level: if a trajectory has very low sinuosity (i.e. is very straight) for a certain distance and follows no features of constrained movement spaces in transportation networks (paths and roads, train tracks, etc.)
- Due to the lage dependency on finding the correct setting: Use Mashine leaning algorithms to find the best setting for TMD such as window size, thresholds for multi criteria analysis, etc. using a large ground proofed data set for a variety of movement types (people of all ages, backgrounds, activity profiles, living and working environment, etc.)


Method:
- not considering ships, airplanes, gondolas, etc. Trams considerd as buses.
- validate the TM from POSMO using the POSMO datamap online tool after downloading the unvalidated data for reference

