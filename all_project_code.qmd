---
title: "Project code"
author: "Lukas Bieri (bieriluk) & Valentin Hett (hettval1)"
date: "02.06.2023"
format: html
editor: source
---



# Improved Transport Mode Detection & Public Transport Punctuality Assessment

## 1. Informationen & Metadaten

### 1.1 Zum Projekt

Fallbeispiel mit Abschlussbericht über die multivariate Analyse am Beispiel der Habitatselektion des Rehs

**Modul:** Research Methods HS22

**Kurs:** Fallstudie MRU Biodiversity and Ecosystems

**Dozierende:** Roland Graf (graf) & Reto Rupf (rupf)

**Unterstützende Lehrpersonen:** Benjamin Sigrist (sigb) & Adrian Hochreutener (hoce)

**Autoren:** Mirjam Scheib (scheimir), Valentin Hett (hettval1), Pascal Luder (luderpas), Lukas Bieri (bieriluk)

**Stand:** 05.01.2023



### 1.2 Ordnerstruktur R-Projekt

Arbeiten erfolgten in einem R-Projekt auf der MS OneDrive über den Account der ZHAW, geteilt mit allen am Projekt mitarbeitenden Personen.

Das Projekt wurde in folgendem Ordner erstellt:
Shared_RProject_ReMe_Team3

Daten welche im R versendet wurden, sind im Unterordner "data" abgelegt.
Resultate, inbesondere Grafiken, wurden im Unterordner "Results" abgelegt.

### 1.3 Verwendete Daten

Verwendete Daten wurden von den Dozierenden und unterstützenden Lehrpersonen beschafft und zur Verfügung gestellt. Für die Auswertung wurden keine eigenen Daten beschafft oder erhoben.

Folgende Daten wurden für die Auswertungen und Modellierungen in der vorliegenden Fallstudie verwendet:

1.  File: Aufgabe3_Homeranges_Rehe_landforst_20221024.csv
    Kurzbeschrieb:
    Stand:
    Metadaten:

2.  File: Aufgabe3_Reh_Waldstruktur_221013.csv
    Kurzbeschrieb:
    Stand:
    Metadaten:

3.  File: Aufgabe4_Datensatz_Habitatnutzung_Modelle_20221031_moodle.csv
    Kurzbeschrieb:
    Stand:
    Metadaten:

4.  File: pk25_wpz.tif
    Kurzbeschrieb:
    Stand:
    Metadaten:

Alle heruntergeladen am 15.11.2022 vom Moodle-Server der ZHAW LSFM im Kurs Research Methods HS22 MSc ENR, Ordner ReMe HS22 MSc ENR/Fallstudie Biodiversity & Ecosystems/N_Daten: https://moodle.zhaw.ch/mod/folder/view.php?id=578940

Ein Grossteil des Codes in R wurde aus den von der Modulleitung auf GitHub zu Verfügung gestellten Übungen zur Fallstudie übernommen und für unsere Zwecke angepasst und ergänzt.

### 1.4 Verwendete Software

**R version 4.2.1 (2022-06-23 ucrt)** -- "Funny-Looking Kid" Copyright (C) 2022 The R Foundation for Statistical Computing Platform: x86_64-w64-mingw32/x64 (64-bit)

**RStudio 2022.07.2+576** "Spotted Wakerobin" Release (e7373ef832b49b2a9b88162cfe7eac5f22c40b34, 2022-09-06) for Windows Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) QtWebEngine/5.12.8 Chrome/69.0.3497.128 Safari/537.36


## 2. Vorbemerkungen & Vorbereitung

Zur Vorbereitung: R-Session neu starten (Restart R) und Konsole berenigen (clear console)

Dann: Funktion die wenn nötig die nötigen Packages installiert und lädt : - lme4 - bbmle - MuMIn - tidyverse - DHARMa - car - MASS - ROCR - sjPlot - ggeffects - sjstats - cowplot - magrittr - gstat - sf - raster - adehabitatHR - maptools - sp - ggspatial - rgeos - rgdal - PerformanceAnalytics - pastecs

```{r}
#| output: false
#| warning: false
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, repos = "http://cran.us.r-project.org", 
                     dependencies = TRUE)
  sapply(pkg, require, character.only = TRUE)
}

packages <- c("ggplot2", "dplyr", "tidyr", "readr", "zoo", "data.table", "sf", "terra", "tmap", "stats", "randomForest", "lubridate", "trajr", "gstat", "geosphere", "nngeo", "vegan", "hms", "tibble", "useful")

ipak(packages)
```
Prüfen ob die benötigten Packages korrekt geladen wurden.
i.O. --> Weiter zum einlesen der Daten

## 3. Daten(vor)verarbeitung

### 3.1 Daten einlesen & anpassen

```{r}
posmo <- read_delim("datasets/posmo_2023-01-01T00-00-00_2023-05-13T23-59-59_bieriluk.csv", delim = ",")

```

Check if the import got the Time Zone for the POSIXct colum correct (compare with the first entry in the imported data with the raw data):
```{r}
str(posmo)
Sys.time()
```

Store your data frame as a spatial data frame and transform the coordinate system from WGS84 (i.e. EPSG 4326) to CH1903+ LV95 (EPSG 2056)
```{r}
posmo <- st_as_sf(posmo, coords = c("lon_x","lat_y"), crs = 4326) |>
  st_transform(2056)

head(posmo)
```

Extract the coordinates into separate colums to use them for euclidean distance calculation:
```{r}
posmo_coordinates <- st_coordinates(posmo)

posmo <- cbind(posmo, posmo_coordinates)
```



### 3.2  Getting an overview & EDA

#### 3.2.1 For how long were the individual tracked? Are there gaps? Were all individuals tracked concurrently or sequentially?
```{r}

head(posmo)
tail(posmo)
```


#### 3.2.2 How many individuals were tracked 
```{r}
posmo$user_id |> unique()
```
--> 1 Individuals, because for the moment we are only working with on data set (not the POSMO Pool)

### 3.3  Filtering & Outlier detection

#### 3.3.1 Filter the data for testing & checkin the method
Choose a single day for this step (13.04.2023, because many different visited places that day) and filter your data:
```{r}
posmo_filter <- posmo  #|>
#    filter(as.Date(datetime) == "2023-04-13")

test <- filter(posmo, hour(datetime) >= 7 & hour(datetime) <= 17)

hour(as_hms("17:00:00"))
```

```{r}
ggplot(posmo_filter, aes(X,Y, color = datetime)) +
  geom_point() +
  geom_path() +
  coord_equal()

tmap_mode(mode = "view")

tm_shape(posmo_filter) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")
```
X = E, Y = N


#### 3.3.2 Remove deuplicate time stamps
Calculate timelag and also remove values with the same time stamp by summarising unsing the mean.
```{r}

posmo_filter_clean <- posmo_filter|>
  st_drop_geometry()|>
  select(datetime, X, Y)|>
  mutate(
    datetime = unclass(datetime)
    ) |>
  group_by(datetime)|>
  summarise(
    X = mean(X, na.rm = TRUE),
    Y = mean(Y, na.rm = TRUE)
  ) |>
  ungroup()|>
  mutate(
    datetime = as.POSIXct(datetime, origin = '1970-01-01', tz = "UTC")
    )|>
  st_as_sf(coords = c("X","Y"), crs = 2056, remove = FALSE) 

n_distinct(posmo_filter_clean$datetime)
n_distinct(posmo_filter$datetime)
```


#### 3.3.3 Temporal sampling interval cleaning
Calculate timelag to figure out a appropriate temporal window:
```{r}
posmo_filter_clean <- posmo_filter_clean |>
  mutate(timelag_s = as.numeric(difftime(lead(datetime), datetime)))

```

Look for negative timelag values and visually validate that they are corrective algorith errors, then eliminate these rows incl. NA's. 
```{r}
posmo_filter_clean |>
    filter(timelag_s < 0)

posmo_filter_clean |>
    filter(is.na(timelag_s))

tm_shape(slice(posmo_filter_clean,1261)) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")
  
posmo_filter_clean <- posmo_filter_clean |>
    filter(timelag_s > 0)

```


So what does the timelag between measurement points look like:
```{r}
tail(posmo_filter_clean)
mean(posmo_filter_clean$timelag_s, na.rm = TRUE)
median(posmo_filter_clean$timelag_s, na.rm = TRUE)
min(posmo_filter_clean$timelag_s, na.rm = TRUE)
max(posmo_filter_clean$timelag_s, na.rm = TRUE)


posmo_filter_clean|> 
  ggplot(aes(timelag_s)) +
  geom_histogram(binwidth = 1) +
  lims(x = c(0, 20000)) +
  scale_y_log10() +
  scale_x_log10()

posmo_filter_clean |> 
  ggplot(aes(datetime, timelag_s)) +
  geom_point() + 
  geom_line()

```

#### 3.3.4 Outlier detection and removal
Calculate further features for outlier detection
```{r}
posmo_filter_clean <- posmo_filter_clean |> 
  mutate(steplength_m = sqrt((X-lead(X,1))^2 + (Y-lead(Y,1))^2)) |> 
  mutate(speed_ms = steplength_m/timelag_s)
posmo_filter_clean
```
X = E, Y = N

Identify and remove outliers
```{r}
mean(posmo_filter_clean$speed_ms, na.rm = TRUE)
median(posmo_filter_clean$speed_ms, na.rm = TRUE)
min(posmo_filter_clean$speed_ms, na.rm = TRUE)
max(posmo_filter_clean$speed_ms, na.rm = TRUE)

posmo_filter_clean |>
    filter(speed_ms > 140)

tm_shape(slice(posmo_filter_clean,1258:1260)) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")
```


### 3.4  Resampling

Adding new rows with the resampled time stamps and linearly interpolating them using na.approx() 
```{r}
# Create a new df with all necessary time stamps

resamp_timestamps <- seq.POSIXt(from = ceiling_date(min(posmo_filter_clean$datetime), "10 sec"),
                                to = floor_date(max(posmo_filter_clean$datetime), "10 sec"), 
                                by = 10)
resamp_timestamps <- as.data.frame(resamp_timestamps)

resamp_timestamps <- resamp_timestamps |> 
  as.data.frame() |> 
  rename(datetime = resamp_timestamps)

# Combine the df with the resulting df adding rows with NA for the nessecary time stamps
posmo_filter_resamp <- posmo_filter_clean |>
  select(datetime, X, Y, geometry) |>
  full_join(resamp_timestamps, by = "datetime") |>
  arrange(datetime)

n_distinct(posmo_filter_resamp$datetime)
sum(n_distinct(posmo_filter_clean$datetime), n_distinct(resamp_timestamps$datetime))

# Linearly interpolate the missing values (coordinates) & Filter to only the resampled rows
posmo_filter_approx <- posmo_filter_resamp |>
  st_drop_geometry()|>
  mutate(X = na.approx(X),
         Y = na.approx(Y)
         ) |>
  filter(second(datetime) %in%  c(0, 10, 20, 30, 40, 50)) |>
  st_as_sf(coords = c("X","Y"), crs = 2056, remove = FALSE)

posmo_filter_approx

tm_shape(posmo_filter_approx) +
  tm_dots()
  tm_basemap("Esri.WorldImagery")

```

## 4. Segmentation

### 4.1 Get an overview
```{r}
ggplot(posmo_filter_approx, aes(X,Y, color = datetime)) +
  geom_point() +
  geom_path() +
  coord_equal()
```
X = E, Y = N

```{r}
posmo_filter_approx|> 
  head(50) |> 
  ggplot(aes(datetime, 1)) +
  geom_point()
```

### 4.2 (a) Specify a temporal windows v for in which to measure Euclidean distances
Calculate timelag to figure out a appropriate temporal window:
```{r}
posmo_filter_approx <- posmo_filter_approx|>
  mutate(timelag_s = as.numeric(difftime(lead(datetime), datetime)))
```

So what does the timelag between measurement points look like:
```{r}
tail(posmo_filter_approx)
mean(posmo_filter_approx$timelag_s, na.rm = TRUE)
median(posmo_filter_approx$timelag_s, na.rm = TRUE)
min(posmo_filter_approx$timelag_s, na.rm = TRUE)
max(posmo_filter_approx$timelag_s, na.rm = TRUE)

```

For this exercise we try to use the data as is and try it with a window of 6 steps and 6 steps forward and backward in the data. This is v = 2min, because the timelag is 10s.

### 4.3 (b) Measure the distance from every point to every other point within this temporal window v
```{r}
posmo_filter_approx <- posmo_filter_approx |> 
  mutate(
    n_plus10 = sqrt((lead(X,10) - X)^2 + (lead(Y,10) - Y)^2),
    n_plus20 = sqrt((lead(X,20) - X)^2 + (lead(Y,20) - Y)^2),
    n_minus10 = sqrt((lag(X,10) - X)^2 + (lag(Y,10) - Y)^2),
    n_minus20 = sqrt((lag(X,20) - X)^2 + (lag(Y,20) - Y)^2),
    steplength_m = sqrt((X-lead(X,1))^2 + (Y-lead(Y,1))^2),
    speed_ms = steplength_m/timelag_s
  )
```
Segmentation: temporal window v = 200s, Filtering: 60s


```{r}
posmo_filter_approx <- posmo_filter_approx |> 
  rowwise() |> 
  mutate(
    stepMean = mean(c(n_minus10, n_minus20, n_plus10, n_plus20))
  ) |> 
  ungroup()
```
Careful, you need rowwise() for the mutate() function to caclulate mean() for every row. You need to ungroup it in the end, because your data frame has the rowwise grouping saved.

### 4.4 (c) Remove “static points”

We need to determine the appropriate threshold where the points are stationary. It helps to visualize the data:
```{r}
ggplot(posmo_filter_approx, aes(stepMean)) +
  geom_histogram(binwidth = 10) +
  geom_vline(xintercept = median(posmo_filter$stepMean, na.rm = TRUE))
```

These are points where the average distance is less than a given threshold or the min speed

To find a good threshold, I tried different distances which I would realistically travel when not being stationary. ave.distance d =100m
A trip (Segment) may be conducted with different transportation modes, and can, therefore, be divided into segments where each segment indicate a certain transport mode. For instance, a trip can start with a car and end with a bus. First, we identify GPS tracking stops that are longer than a specific threshold (30s). A stop is considered when consecutive points in an interval of above 30 s do not have a speed higher than 2 km/h. The stops are where the transportation mode might have changed and subsegments might be formed.
```{r}
posmo_filter_segm <- posmo_filter_approx |>
    ungroup() |>
    mutate(
      static = (stepMean < 100) | (lead(speed_ms,1) < 0.555555 & lead(speed_ms,2) < 0.555555 & lag(speed_ms,1) < 0.555555 & lag(speed_ms,2) < 0.555555)) |>
    drop_na(static)
```

### 4.5 Visualize stops
```{r}
ggplot(posmo_filter_segm, aes(X,Y)) +
  geom_path() +
  geom_point(aes(color = static)) +
  coord_equal()

tm_shape(posmo_filter_segm) +
  tm_dots(col = "static") +
  tm_basemap("Esri.WorldImagery")

```
Moving 10 in approx. 300sec being the threshold and no more than 2km/h within 30s for being stationary seems to line up well with the reality when visualizing it.

### 4.6 Segment-based analysis (segmentation at stationary points)
Create function for segmentation at the stationary points:
```{r}
rle_id <- function(vec) {
    x <- rle(vec)$lengths
    as.factor(rep(seq_along(x), times = x))
}
```

Run the function on the data:
```{r}
posmo_filter_segm <- posmo_filter_segm |>
    mutate(segment_id = rle_id(static))

head(posmo_filter_segm)
```

### 4.7 Visualize segmented trajectories
```{r}
ggplot(posmo_filter_segm, aes(X,Y)) +
  geom_path() +
  geom_point(aes(color = segment_id)) +
  coord_equal()

tm_shape(posmo_filter_segm) +
  tm_dots(col = "segment_id") +
  tm_basemap("Esri.WorldImagery")
```

Seems to line up well with ground truth for that day and the trips I took. If I would want to improve the segmentation, I would have to compare the details with reality and maybe smoothen out the differences in timelags.

Remove segments with a duration of less than 60s and static points
```{r}
posmo_filter_short_segm <- posmo_filter_segm |> 
  group_by(segment_id)|>
  summarise(
    seg_length = sum(timelag_s, na.rm = TRUE)
  ) |>
  ungroup()|>
  mutate(
    short = seg_length < 60
  ) |>
  select(segment_id, short) |>
  st_drop_geometry()

posmo_filter_segm_clean <- posmo_filter_segm |> 
  left_join(posmo_filter_short_segm, by = "segment_id") |> 
  filter(static == FALSE) |>
  filter(short == FALSE) |>
  select(datetime, X, Y, geometry, segment_id)

tm_shape(posmo_filter_segm_clean) +
  tm_dots(col = "segment_id") +
  tm_basemap("Esri.WorldImagery")

unique(posmo_filter_segm_clean$segment_id)
```
**Offene Frage: Warum werden im Code der Exercise die "static points" nicht entfernt? So richtig wie ich das hier gemacht habe?**


## 5. Feature extraction

### 5.1 Feature extraction on the raw point data
```{r}
posmo_filter_segm_clean <- posmo_filter_segm_clean |> 
  mutate(timelag_s = as.numeric(difftime(lead(datetime), datetime)),
         steplength_m = sqrt((X-lead(X,1))^2 + (Y-lead(Y,1))^2),
         speed_ms = steplength_m/timelag_s,
         acc_mss = as.numeric(speed_ms - (lead(speed_ms)) / timelag_s),
         long = st_coordinates(st_transform(posmo_filter_segm_clean, 4326))[,1], 
         lat = st_coordinates(st_transform(posmo_filter_segm_clean, 4326))[,2],
         azi = c(st_azimuth(head(st_geometry(posmo_filter_segm_clean),-1),
                            head(lead(st_geometry(posmo_filter_segm_clean),1),-1)),NA)
         ) |> 
  rowid_to_column(var = "id") |>
  drop_na() 
  
#To add in future if appropriate:
#,
#        bearing_from = atan2((cos(lat)*sin(lead(lat)) - sin(lat)*cos(lead(lat))* cos(long - lead(long))), (cos(lead(lat))* sin(long - lead(long)))),
#         bearing_geosp = bearing(st_coordinates(st_transform(posmo_filter_segm_clean, 4326)), lead(st_coordinates(st_transform(posmo_filter_segm_clean, 4326)),1)),

```
**Wird Bearing hier korrekt berechnet? Was ist der Unterschied zwischen Azimut, Bearing, Direction, turning angles und heading? Was wäre hier am angebrachtesten**

### 5.2 Feature extraction & summary by segment
Therefore, features such as average speed, average acceleration, maximum and minimum speed, acceleration during each segment, segment distance, direction, and duration, are calculated for each segment. 
```{r}
 
posmo_filter_segm_sry <- posmo_filter_segm_clean |> 
  group_by(segment_id)|>
  summarise(
    avgspeed_ms = mean(speed_ms, na.rm = TRUE),
    avgacc_mss = mean(acc_mss, na.rm = TRUE),
    maxspeed_ms = max(speed_ms, na.rm = TRUE),
    minspeed_ms = min(speed_ms, na.rm = TRUE),
    maxacc_mss = max(acc_mss, na.rm = TRUE),
    minacc_mss = min(acc_mss, na.rm = TRUE),
    seg_dist_m = sum(steplength_m, na.rm = TRUE),
    seg_avgdir = mean(azi, na.rm = TRUE),
    seg_time_s = sum(timelag_s, na.rm = TRUE)#,
#    seg_sinuos = TrajSinuosity2(TrajFromCoords(drop_na(posmo_filter_segm_clean)))
  )

#Sinuosity is complicated, need to create a function. For the future:

#sinuosity <- function(traj) {
#  for ( in traj) {
#  print(i)
#}
#    TrajSinuosity2(TrajFromCoords(drop_na(traj))) 
#}

```
**Durchschnittliche Richtung eines Segments als mittelwert des Azimuts korrekt? vmtl. nicht oder?**
**Wie wird eine Funktions erstellt die o.g. Sinuosity-Funktion auf alle Segmente nach ID anwendet?**


## 6. Preliminary multi criteria analysis to eliminate walking segments

However, walking can easily be identified in the GPS-tracking data based on three conditions:
1. segment must have at least two positional recordings, and the segment’s duration should be more than 60 s Gong et al. (2012a). 
2. The second condition is that the segment’s average speed should not be greater than 6 km/h 
(Stopher et al., 2008). 
3. The third condition is that each subsequent point’s maximum speed should not be greater than 12 km/h (Gong et al., 2012b; Stopher et al., 2008). All selected walk segments are checked 
manually in GIS multi-criteria process because, it is difficult to differentiate between various modes in traffic and the traffic pattern for these modes were rather similar (walk, car, bus). After identification of the walk transport mode, those segments are removed from the dataset. 
```{r}

posmo_filter_segm_clean <- left_join(posmo_filter_segm_clean, st_drop_geometry(posmo_filter_segm_sry), by = "segment_id")

posmo_filter_segm_walks <- posmo_filter_segm_clean |> 
  mutate(
    walks = seg_time_s > 60 & avgspeed_ms <= 1.66666 & maxspeed_ms < 3.33333
  )

posmo_filter_segm_onlywalks <- posmo_filter_segm_walks |> 
  filter(walks == TRUE)

posmo_filter_segm_nowalks <- posmo_filter_segm_walks |> 
  filter(walks == FALSE)

  tm_shape(posmo_filter_segm_onlywalks) +
  tm_dots(col = "walks") +
  tm_basemap("Esri.WorldImagery")

```


## 7. Unsupervised algorithm using k-means clustering
```{r}
posmo_filter_seg_kmeans4 <- posmo_filter_segm_nowalks |> 
  st_drop_geometry() |> 
  select(steplength_m, speed_ms, acc_mss, azi) |> 
  data.matrix() |> 
  kmeans(4)

posmo_filter_seg_kmeans4
```

Manually assign TM to the clusters
```{r}
posmo_filter_seg_kmeans4

posmo_filter_seg_cluster |>
  filter(as.Date(datetime) == "2023-04-13") |>
  filter(kmeans4 == 3) |>
  tm_shape() +
  tm_dots(col = "kmeans4") +
  tm_basemap("Esri.WorldImagery")

```

Add cluster number to data frame (later with manually assigned label)
```{r}
posmo_filter_seg_cluster <- posmo_filter_segm_nowalks |> 
  mutate(
    kmeans4 = posmo_filter_seg_kmeans4$cluster
  )

posmo_filter_seg_cluster |>
  filter(as.Date(datetime) == "2023-05-13") |>
  tm_shape() +
  tm_dots(col = "kmeans4") +
  tm_basemap("Esri.WorldImagery")

```
Good dates for Verification are 2023-05-12 (lonk bike track) and 2023-04-13 (ÖV and car)


Test for non-multi-clusterd segments:
```{r}
test <- posmo_filter_seg_cluster |> 
  group_by(segment_id)|>
  summarise(
    avgspeed_ms = mean(speed_ms, na.rm = TRUE),
    avgacc_mss = mean(acc_mss, na.rm = TRUE),
    maxspeed_ms = max(speed_ms, na.rm = TRUE),
    minspeed_ms = min(speed_ms, na.rm = TRUE),
    maxacc_mss = max(acc_mss, na.rm = TRUE),
    minacc_mss = min(acc_mss, na.rm = TRUE),
    seg_dist_m = sum(steplength_m, na.rm = TRUE),
    seg_avgdir = mean(azi, na.rm = TRUE),
    seg_time_s = sum(timelag_s, na.rm = TRUE),
    seg_clear = all(min(kmeans4) == max(kmeans4), na.rm = TRUE)
  )

test |>
  filter(seg_clear == TRUE) |>
  tm_shape() +
  tm_dots(col = "segment_id") +
  tm_basemap("Esri.WorldImagery")
```
**The only ones clearly identified are walks that havent been identified as such by the multi-criteria analysis**



## 8. GIS multi-criteria process 

### 8.1 Preparation
```{r}

```


### 8.2 Bike mode detection
For the bike mode, three rules are applied:
1. First, the average speed of a trip segment is assumed below 25 km/h. 
2. Second, the maximum speed of the segment should not be greater than 40 km/h. 
3. Third, the total distance in a segment should be below 20 km. 

```{r}

```


### 8.3 Train mode detection
For the train mode, three rules are applied:
1. The railway network, and the train stations are collected and used for detecting train mode.
2. Second, the distance from each point of the trip segment to the nearest railway or commuter rail link should be less than 10 m. 
3. Third, the maximum distance of the first and endpoint to the nearest train station should be 75 m (Gong et al., 2012b).

First, based on multimodal transportation network, each sequential pair of GPS points within a train segment is matched to the similar link of the train network.
```{r}

```



### 8.4 Bus mode detection
Three rules, therefore, are applied to identify the bus mode:
1. First, each segment’s positional recording needs to be close to bus routes with unique features, such as bus stops and lanes. 
2. Second, the average speed of 88 km/h is considered (Gong et al., 2012b), while the maximum speed of a segment should be 100 km/h based on the traffic rules. 
3. Third, the maximum distance to the bus station should be less than 75 m. 

The remaining trip segments are considered potential car mode after applying the bus mode rules.

```{r}

```

### 8.5 Car mode detection
The rule applied in further identifying the car mode is that each car segment needed to follow the transportation network, and the maximum speed should not be greater than 180 km/h (Biljecki et al., 2013a). 

```{r}

```



**Ideas:**
- using similarity for comparing bus routes and bus departure times

st_join(join = st_is_within_distance, dist = 10)



## 9. Supervised learning algorithms

```{r}
#randomForest(Species~., data=train, proximity=TRUE) print(rf)

```


